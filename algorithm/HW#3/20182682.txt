<설계 방법>
1. sample을 받아와서 완전이진트리를 구현한다.
 1-1. 파일이 열리면 여러 개의 TreeNode를 inputSize만큼 할당(=tree)해준다. 
 1-2. 자식 노드의 왼쪽 인덱스는 부모 인덱스의 두배, 오른쪽 인덱스는 부모인덱스의 두배보다 1만큼 큰 것을 이용하여 tree에 할당해준다.
 1-3. 해당 tree를 사용할 수 있도록 전역변수로 설정한 root에 tree의 첫번째 노드를 넣고, 후에 쓰일 마지막 노드를 전역변수로 설정한 lastNode에 저장한다.

2. 해당 노드까지의 경로를 구하기 위해 vector와 pair를 사용한다.  root를 recursive하게 돌면서 거쳐가는 노드와 횟수를 pair를 이용해 묶어 branch 벡터에 저장한다. (이 때 branch는 전역 변수로 선언한다.)

3. 이 때 리프 노드를 만나면 저장된 노드와 횟수를 이용하여 경로 값을 계산한다. 
 3-1. 저장된 노드와 10의 (횟수의 역순) 제곱만큼 곱한 뒤 이를 다 합한다. 그 후 합한 값을 다 모으는 pathSum 벡터에 값을 넣는다.

4. 리프 노드를 만날 때까지 중복으로 카운트되는 횟수가 있으므로 이를 제외시키는 과정을 수행한다.
 4-1. 만약 현재 노드가 마지막 노드라면 branch의 마지막 값을 빼고 횟수도 한번 차감한다. 이는 recursive함수가 수행되기 전에 한다.
 4-2. 만약 현재 노드가 루트 노드라면 루트의 오른쪽 노드들을 계산해야하므로 branch를 비우고 cnt도 1로 초기화한다. 루트와 cnt를 branch에 push 한다.
 4-3. 만약 현재 노드가 리프 노드와 루트 노드가 둘다 아니라면 해당 노드의 오른쪽 노드부터 시작해 왼쪽 가지의 수를 센다(countBranch함수 사용). 그리고 그 가짓수만큼 branch에 pop을 진행하고 횟수도 차감한다. 이 때 가지수를 셀 때 사용한 전역변수로 선언된 vector(nodeNum)을 초기화 시켜준다. 이는 right 방향의 recursive 함수를 사용하기 전에 수행한다.

5. pathSum에 모든 노드의 경로 값이 저장되었다면 이를 다 더한 뒤(calPathSum함수 사용) 그 값을 반환한다.

<correctness>
문제에서 요구하는 경로 값은 (마지막 노드가 1의 자리, 그 부모 노드가 10의 자리, 부모의 부모의 노드가 100의 자리...)이다. 리프 노드까지의 거쳐가는 노드들을 count하고 그 노드들의 count값의 역순만큼 10의 제곱을 해준 뒤 다 더하면 자릿수가 일치하게 되고 요구되는 경로에 맞게 된다. 
example1 예제를 보면 이것을 완전이진트리로 구현하면 
    2
  3   0
1  2
이렇게 된다. 문제에서 요구하는 경로는 리프 노드에 따라 231, 232, 20이므로 이는 (10^2*2+10^1*3+10^0*1),  (10^2*2+10^1*3+10^0*2),  (10^1*2+10^0*0) 이다. 이는 곧 노드들의 count값의 역순만큼 10의 제곱을 해준 뒤 더하는 것과 같다. 그러므로 이를 통해 구현한 코드는 옳다.

<efficiency>
calPathSum안의 for문에서 최대 n번 연산
getPathSum 안의 for문에서 최대 n번 연산
buildTree안의 for문에서 최대 n번 연산
이 외에 반복되는 연산이 없으므로
이 코드의 시간복잡도는 O(n)