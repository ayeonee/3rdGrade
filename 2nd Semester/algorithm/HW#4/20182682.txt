<설계 방법>
고등학교 때 확률과통계 과목에서 배운 길찾기 방법을 사용했다.
아래와 같이 경로가 그리드가 있다고 하면 좌측 최상단에서 우측 최하단까지 가는 길은 다음과 같다.
+----+---+---+
|   1  |  1  |  1 |
+----+---+---+
|   1  |  2  | 3  |
+----+---+---+
|   1  |  3  | 6  |
+----+---+---+
만약 행이나 열이 1개라고 한다면 목적지까지 가는 길은 1가지뿐이므로 행, 열이 1인 경우에는 1으로 표시한다.
그리고 1이 아닐 경우에는 각각 좌측과 상단에 있는 값을 더해준다.
즉, arr[i][j]=arr[i-1][j] + arr[i][j-1] 이 된다. 
main에서 행과 열을 받아와 이중for문을 사용하여 각각의 자리에 해당하는 값을 넣어주고, 목적지에 해당하는
가장 마지막 값을 반환한다.

<correctness>
[arr[i][j]의 값이 해당 공간까지 도달하는데 걸리는 경로들의 경우의 수인가?] = yes

Loop invariant : i번째 loop가 끝나면 arr[i][j] 값에 해당 공간까지 도달하는 경로들의 수가 저장된다.

Inductive Hypothesis : i번째 loop가 끝났을 때 invariant가 성립한다면 i+1번째 loop가 끝났을 때도 성립한다.

base : i=0이면 출발지와 도착지가 같으므로 경로의 수는 1이다. =TRUE

inductive step : i번째 loop에선, arr[i][j]의 값을 정해주게 되는데 이 때 길찾기 방법이 적용된다. 해당 공간에 도달하는 경로의 수는 그 공간에 오기 직전까지의 값들을 더해주면 된다. 각각 arr[i-1][j], arr[i][j-1]의 값인데 이 두 값도 loop invaraint에 따라 경로들의 수가 저장되어 있으므로 arr[i][j]에도 해당 공간까지 도달하는 경로들의 수가 저장된다. (i+1)번째 loop에서도 경로의 수가 저장된 인접한 두 값을 더해주므로 loop invaraint가 성립한다. = TRUE

conclusion : 모든 루프가 종료되었을 때 arr[i][j] 값에 해당 공간까지 도달하는 경로들의 수가 저장되므로 loop invariant를 만족시킨다.

<efficiency>
m개의 행 안에 n개의 열만큼 반복하므로
m x n 번의 연산 수행,
그러므로 전체코드의 시간복잡도는 O(mn)